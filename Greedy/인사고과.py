# 프로그래머스 Lv.3 인사고과
# 전체 데이터를 고려하여 정렬 기준 설정, 문제에서 요구하는 바를 정확히 파악해서 탐색 범위 한정하기

def solution(scores):
    # 전체 사원들의 석차와 인센티브 수령 여부가 중요한 것이 아니라,
    # 완호의 인센티브 수령 여부와 석차 & 인센티브를 받지 못하는 사람만 구하면 되는 문제
    answer, wanho, wanho_sum = 1, scores[0], sum(scores[0]) # 완호의 점수 저장
    
    # 한 번의 탐색으로 완호의 석차를 구하기 위해 미리 정렬
    # 점수 합이 높은 순으로 석차를 정하므로, 우선 근무 태도 점수가 높은 사원 순으로 내림차순 정렬
    # 동료 평가 점수는 우선 오름차순 정렬, 탐색하면서 큰 값으로 업데이트하여 최고점을 찾을 수 있음
    scores.sort(key=lambda x: (-x[0], x[1]))
    highest_company = 0
    
    for score in scores:
        if wanho[0] < score[0] and wanho[1] < score[1]: return -1
        
        # 근무태도 점수 내림차순으로 정렬했으므로, 현재 탐색중인 사원의 근무태도 점수는
        # 무조건 앞서 탐색한 모든 사원들의 근무태도 점수보다 낮거나 같음
        # 따라서 동료평가 점수가 현재까지의 최고값보다 높다면 (근무 태도 점수가 더 낮은 경우는 고려X)
        # 해당 사원은 인센티브를 받을 수 있는 사원
        if highest_company <= score[1]:
            # 완호보다 석차가 높은 사원인 경우 완호의 석차 변경
            if wanho_sum < score[0] + score[1]: answer += 1
            
            # 동료평가 점수 최고값 업데이트 (오름차순 정렬했으므로, max 함수를 사용하지 않아도
            # 업데이트 하는 값이 무조건 (같은 근무태도 점수 중에서) 현재까지의 최고값임이 보장됨)
            highest_company = score[1]
    
    return answer
